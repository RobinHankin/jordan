---
title: "Jordan algebras in R"
author: "Robin K. S. Hankin"
output:
  pdf_document: default
  html_document:
    df_print: paged
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{involutions}
  %\usepackage[utf8]{inputenc}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("jordan")
```

# Jordan algebras

A _Jordan algebra_ is a nonassociative algebra over the reals with
a bilinear multiplication that satisfies the following identities:

$$xy=yx$$

$$(xy)(xx) = x(y(xx))$$

(the second identityis known as the Jordan identity).  In literature
one usually indicates multiplication by juxtaposition but one
sometimes sees $x\circ y$.  Package idiom is to use an asterisk, as in
`x*y`.  There are five types of Jordan algebras:

* Real symmetric matrices, class `real_symmetric_matrix`,
    abbreviated in the package to `rsm`
* Complex Hermitian matrices, class `complex_herm_matrix`,
    abbreviated to `chm`
* Quaternionic Hermitian matrices, class
    `quaternion_herm_matrix`, abbreviated to `qhm`
* Albert algebras, the space of $3\times 3$
    Hermitian octonionic matrices, class `albert`
* Spin factors, class `spin`

(of course, the first two are special cases of the next).  The
`jordan` package provides functionality to manipulate jordan objects
using natural R idiom.  Objects of all these classes are stored in
dataframe (technically, a matrix) form with columns being elements of
the jordan algebra.  The first four classes are matrix-based in the
sense that the algebraic objects are symmetric or Hermitian matrices
(the S4 class is `jordan_matrix`).  The fifth class, spin factors, is
not matrix based.

## Matrix-based Jordan algebras

The four matrix-based Jordan algebras have elements
These all behave in the same way from a package idiom perspective.

Consider:

```{r}
a <- rqhm()
a
```




```{r}
set.seed(0)
rspin()
```

This illustrates many features of the package.


# Special identities

In 1963, C. M. Glennie discovered a pair of identities satisfied by
special Jordan albgebras but not the Albert algebra.  Defining

\[
U_x(y) = 2x(xy)-(xx)y
\]

\[
\left\lbrace x,y,z\right\rbrace=
2(x(yz)+(xy)z - (xz)y)
\]
 
(it can be shown that Jacobson's identity $U_{U_x(y)}=U_xU_yU_x$
holds), Glennie's identities are

\[
H_8(x,y,z)=H_8(y,x,z)\qquad H_9(x,y,z)=H_9(y,x,z)
\]

(see McCrimmon 2004 for details), where

\[
H_8(x,y,z)= \left\lbrace U_x U_y(z),z, xy\right\rbrace-U_xU_yU_z(xy)
\]

and
\[
H_9(x,y,z)= 2U_x(z) U_{y,x}U_z(yy)-U_x U_z U_{x,y} U_y(z)
\]

## Numerical verification of Jacobson

We may verify Jacobson's identity:

```{r,label=define_U_and_diff}
U <- function(x){function(y){2*x*(x*y)-(x*x)*y}}
diff <- function(x,y,z){
     LHS <- U(x)(U(y)(U(x)(z)))
     RHS <- U(U(x)(y))(z)
     return(LHS-RHS)  # zero if Jacobson holds
}
```

Then we may numerically verify Jacobson for type 3-5 Jordan algebras:

```{r,label=jacobsonverification,cache=TRUE}
diff(ralbert(),ralbert(),ralbert())
diff(rqhm(),rqhm(),rqhm())
diff(rspin(),rspin(),rspin())
```

showing agreement to numerical accuracy (the output is close to zero).
We can now verify Glennie's $G_8$ and $G_9$ identities.

## Numerical verification of $G_8$

```{r,label=defBH8G8}
B <- function(x,y,z){2*(x*(y*z) + (x*y)*z - (x*z)*y)}  # bracket function
H8 <- function(x,y,z){B(U(x)(U(y)(z)),z,x*y) - U(x)(U(y)(U(z)(x*y)))}
G8 <- function(x,y,z){H8(x,y,z)-H8(y,x,z)}
```

and so we verify for type 3 and type 5 Jordans:

```{r,label=verifyG8special,cache=TRUE}
G8(rqhm(1),rqhm(1),rqhm(1))
G8(rspin(1),rspin(1),rspin(1))
```

again showing acceptable accuracy.  The identity is *not* true for
Albert algebras:

```{r,cache=TRUE}
G8(ralbert(1),ralbert(1),ralbert(1))
```

## Numerical verification of $G_9$

```{r,label=defineH9G9}
L <- function(x){function(y){x*y}}
U <- function(x){function(y){2*x*(x*y)-(x*x)*y}}
U2 <- function(x,y){function(z){L(x)(L(y)(z)) + L(y)(L(x)(z)) - L(x*y)(z)}}
H9 <- function(x,y,z){2*U(x)(z)*U2(y,x)(U(z)(y*y)) - U(x)(U(z)(U2(x,y)(U(y)(z))))}
G9 <- function(x,y,z){H9(x,y,z)-H9(y,x,z)}
```

Then we may verify the `G9()` identity for type 3 Jordans:

```{r,verifyG9identity,cache=TRUE}
G9(rqhm(1),rqhm(1),rqhm(1))
```

However, the Albert algebra does not satisfy the identity:

```{r,albertH9G9,cache=TRUE}
G9(ralbert(1),ralbert(1),ralbert(1))
```
